/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * FRED API
 * API for accessing economic data from the Federal Reserve Economic Data (FRED) database.
 * OpenAPI spec version: 1.0.2
 */
import type {
	QueryFunction,
	QueryKey,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";
import { useQuery } from "@tanstack/react-query";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import { HttpResponse, delay, http } from "msw";

import axios from "./axiosClient";

export type GetTagsSeriesParams = {
	/**
	 * Get FRED tags. Optionally, filter results by tag name, tag group, or search. FRED tags are attributes assigned to series. See the related request fred/related_tags
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * A semicolon delimited list of tag names to only include in the response. See the related request fred/related_tags.
	 */
	tag_names?: string;
	/**
	 * A semicolon delimited list of tag names that series match none of.
	 */
	exclude_tag_names?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending order for attribute values specified by order_by.
	 */
	sort_order?: string;
};

export type GetRelatedTagsParams = {
	/**
	 * Get FRED tags. Optionally, filter results by tag name, tag group, or search. FRED tags are attributes assigned to series. See the related request fred/related_tags
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * A semicolon delimited list of tag names to only include in the response. See the related request fred/related_tags.
	 */
	tag_names?: string;
	/**
	 * A tag group id to filter tags by type.
	 */
	tag_group_id?: string;
	/**
	 * The words to find matching tags with.
	 */
	search_text?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending order for attribute values specified by order_by.
	 */
	sort_order?: string;
};

export type GetTagsParams = {
	/**
	 * Get FRED tags. Optionally, filter results by tag name, tag group, or search. FRED tags are attributes assigned to series. See the related request fred/related_tags
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * A semicolon delimited list of tag names to only include in the response. See the related request fred/related_tags.
	 */
	tag_names?: string;
	/**
	 * A tag group id to filter tags by type.
	 */
	tag_group_id?: string;
	/**
	 * The words to find matching tags with.
	 */
	search_text?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending order for attribute values specified by order_by.
	 */
	sort_order?: string;
};

export type GetSourceReleasesParams = {
	/**
	 * #Description
	 */
	The?: string;
	/**
	 * Get all sources of economic data.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a source.
	 */
	source_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending order for attribute values specified by order_by.
	 */
	sort_order?: string;
};

export type GetSourceParams = {
	/**
	 * Get all sources of economic data.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a source.
	 */
	source_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
};

export type GetSourcesParams = {
	/**
	 * Get all sources of economic data.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending order for attribute values specified by order_by.
	 */
	sort_order?: string;
};

export type GetSeriesVintagedatesParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
};

export type GetSeriesUpdatesParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * The value of the filter_variable attribute to filter results by.
	 */
	filter_value?: string;
	/**
	 * Start time for limiting results for a time range, can filter down to minutes
	 */
	start_time?: string;
	/**
	 * End time for limiting results for a time range, can filter down to minutes
	 */
	end_time?: string;
};

export type GetSeriesTagsParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending observation_date order.
	 */
	sort_order?: string;
};

export type GetSeriesSearchRelatedTagsParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The words to match against economic data series.
	 */
	series_search_text?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * A semicolon delimited list of tag names that series match all of.
	 */
	tag_names?: string;
	/**
	 * A semicolon delimited list of tag names that series match none of.
	 */
	exclude_tag_names?: string;
	/**
	 * A tag group id to filter tags by type.
	 */
	tag_group_id?: string;
	/**
	 * The words to find matching tags with.
	 */
	tag_search_text?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending observation_date order.
	 */
	sort_order?: string;
};

export type GetSeriesSearchTagsParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The words to match against economic data series.
	 */
	series_search_text?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * A semicolon delimited list of tag names that series match all of.
	 */
	tag_names?: string;
	/**
	 * A tag group id to filter tags by type.
	 */
	tag_group_id?: string;
	/**
	 * The words to find matching tags with.
	 */
	tag_search_text?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending observation_date order.
	 */
	sort_order?: string;
};

export type GetSeriesSearchParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The words to match against economic data series.
	 */
	search_text?: string;
	/**
	 * Determines the type of search to perform.
	 */
	search_type?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Order results by values of the specified attribute.
	 */
	order_by?: string;
	/**
	 * Sort results is ascending or descending observation_date order.
	 */
	sort_order?: string;
	/**
	 * The attribute to filter results by.
	 */
	filter_variable?: string;
	/**
	 * The value of the filter_variable attribute to filter results by.
	 */
	filter_value?: string;
	/**
	 * A semicolon delimited list of tag names that series match all of.
	 */
	tag_names?: string;
	/**
	 * A semicolon delimited list of tag names that series match none of.
	 */
	exclude_tag_names?: string;
};

export type GetSeriesReleaseParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
};

export type GetSeriesObservationsParams = {
	/**
	 * Get the observations or data values for an economic data series.
	 */
	Description?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
	/**
	 * The maximum number of results to return.
	 */
	limit?: string;
	/**
	 * non-negative integer, optional, default: 0
	 */
	offset?: number;
	/**
	 * Sort results is ascending or descending observation_date order.
	 */
	sort_order?: string;
	/**
	 * The start of the observation period.
	 */
	observation_start?: string;
	/**
	 * The end of the observation period.
	 */
	observation_end?: string;
	/**
	 * A key that indicates a data value transformation.
	 */
	units?: string;
	/**
	 * An optional parameter that indicates a lower frequency to aggregate values to. The FRED frequency aggregation feature converts higher frequency data series into lower frequency data series (e.g. converts a monthly data series into an annual data series). In FRED, the highest frequency data is daily, and the lowest frequency data is annual. There are 3 aggregation methods available- average, sum, and end of period. See the aggregation_method parameter.
	 */
	frequency?: unknown;
	/**
	 * A key that indicates the aggregation method used for frequency aggregation. This parameter has no affect if the frequency parameter is not set.
	 */
	aggregation_method?: string;
	/**
	 * An integer that indicates an output type.
	 */
	output_type?: number;
	/**
	 * Vintage dates are used to download data as it existed on these specified dates in history. Vintage dates can be specified instead of a real-time period using realtime_start and realtime_end.
	 */
	vintage_dates?: string;
};

export type GetSeriesCategoriesParams = {
	/**
	 * Get an economic data series.
	 */
	"Description:"?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
};

export type GetSeriesParams = {
	/**
	 * Get an economic data series.
	 */
	"Description:"?: string;
	/**
	 * Read API Keys for more information.
	 */
	api_key?: string;
	/**
	 * A key or file extension that indicates the type of file to send.
	 */
	file_type?: string;
	/**
	 * The id for a series.
	 */
	series_id?: string;
	/**
	 * The start of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_start?: string;
	/**
	 * The end of the real-time period. For more information, see Real-Time Periods.
	 */
	realtime_end?: string;
};

export type GetReleaseTablesFileType =
	(typeof GetReleaseTablesFileType)[keyof typeof GetReleaseTablesFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseTablesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseTablesParams = {
	api_key?: string;
	release_id: number;
	file_type?: GetReleaseTablesFileType;
	element_id?: number;
	include_observations?: boolean;
	observation_date?: string;
};

export type GetReleaseRelatedTagsSortOrder =
	(typeof GetReleaseRelatedTagsSortOrder)[keyof typeof GetReleaseRelatedTagsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseRelatedTagsSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetReleaseRelatedTagsOrderBy =
	(typeof GetReleaseRelatedTagsOrderBy)[keyof typeof GetReleaseRelatedTagsOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseRelatedTagsOrderBy = {
	series_count: "series_count",
	popularity: "popularity",
} as const;

export type GetReleaseRelatedTagsFileType =
	(typeof GetReleaseRelatedTagsFileType)[keyof typeof GetReleaseRelatedTagsFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseRelatedTagsFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseRelatedTagsParams = {
	api_key?: string;
	release_id: number;
	file_type?: GetReleaseRelatedTagsFileType;
	tag_names: string;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetReleaseRelatedTagsOrderBy;
	sort_order?: GetReleaseRelatedTagsSortOrder;
};

export type GetReleaseTagsSortOrder =
	(typeof GetReleaseTagsSortOrder)[keyof typeof GetReleaseTagsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseTagsSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetReleaseTagsOrderBy =
	(typeof GetReleaseTagsOrderBy)[keyof typeof GetReleaseTagsOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseTagsOrderBy = {
	name: "name",
	group_id: "group_id",
} as const;

export type GetReleaseTagsFileType =
	(typeof GetReleaseTagsFileType)[keyof typeof GetReleaseTagsFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseTagsFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseTagsParams = {
	api_key?: string;
	release_id: number;
	file_type?: GetReleaseTagsFileType;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetReleaseTagsOrderBy;
	sort_order?: GetReleaseTagsSortOrder;
	search_text?: string;
};

export type GetReleaseSourcesFileType =
	(typeof GetReleaseSourcesFileType)[keyof typeof GetReleaseSourcesFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseSourcesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseSourcesParams = {
	api_key?: string;
	release_id: number;
	file_type?: GetReleaseSourcesFileType;
	realtime_start?: string;
	realtime_end?: string;
};

export type GetReleaseSeriesSortOrder =
	(typeof GetReleaseSeriesSortOrder)[keyof typeof GetReleaseSeriesSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseSeriesSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetReleaseSeriesOrderBy =
	(typeof GetReleaseSeriesOrderBy)[keyof typeof GetReleaseSeriesOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseSeriesOrderBy = {
	series_id: "series_id",
	title: "title",
	units: "units",
	frequency: "frequency",
	seasonal_adjustment: "seasonal_adjustment",
	realtime_start: "realtime_start",
	realtime_end: "realtime_end",
	last_updated: "last_updated",
	observation_start: "observation_start",
	observation_end: "observation_end",
	popularity: "popularity",
	group_popularity: "group_popularity",
} as const;

export type GetReleaseSeriesFileType =
	(typeof GetReleaseSeriesFileType)[keyof typeof GetReleaseSeriesFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseSeriesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseSeriesParams = {
	api_key?: string;
	release_id: number;
	file_type?: GetReleaseSeriesFileType;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetReleaseSeriesOrderBy;
	sort_order?: GetReleaseSeriesSortOrder;
	filter_variable?: string;
	filter_value?: string;
};

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseDatesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseDatesFileType =
	(typeof GetReleaseDatesFileType)[keyof typeof GetReleaseDatesFileType];

export type GetReleaseDatesParams = {
	api_key?: string;
	file_type?: GetReleaseDatesFileType;
	release_id: number;
	realtime_start?: string;
	realtime_end?: string;
};

export type GetReleaseInfoFileType =
	(typeof GetReleaseInfoFileType)[keyof typeof GetReleaseInfoFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleaseInfoFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleaseInfoParams = {
	api_key?: string;
	file_type?: GetReleaseInfoFileType;
	release_id: number;
	realtime_start?: string;
	realtime_end?: string;
};

export type GetReleasesSortOrder =
	(typeof GetReleasesSortOrder)[keyof typeof GetReleasesSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleasesSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetReleasesOrderBy =
	(typeof GetReleasesOrderBy)[keyof typeof GetReleasesOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleasesOrderBy = {
	release_id: "release_id",
	name: "name",
	press_release: "press_release",
	realtime_start: "realtime_start",
	realtime_end: "realtime_end",
} as const;

export type GetReleasesFileType =
	(typeof GetReleasesFileType)[keyof typeof GetReleasesFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetReleasesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetReleasesParams = {
	api_key?: string;
	file_type?: GetReleasesFileType;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetReleasesOrderBy;
	sort_order?: GetReleasesSortOrder;
	filter_variable?: string;
	filter_value?: string;
};

export type GetCategoryRelatedTagsSortOrder =
	(typeof GetCategoryRelatedTagsSortOrder)[keyof typeof GetCategoryRelatedTagsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryRelatedTagsSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetCategoryRelatedTagsOrderBy =
	(typeof GetCategoryRelatedTagsOrderBy)[keyof typeof GetCategoryRelatedTagsOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryRelatedTagsOrderBy = {
	series_count: "series_count",
	popularity: "popularity",
} as const;

export type GetCategoryRelatedTagsFileType =
	(typeof GetCategoryRelatedTagsFileType)[keyof typeof GetCategoryRelatedTagsFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryRelatedTagsFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategoryRelatedTagsParams = {
	api_key?: string;
	file_type?: GetCategoryRelatedTagsFileType;
	category_id: number;
	tag_names: string;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetCategoryRelatedTagsOrderBy;
	sort_order?: GetCategoryRelatedTagsSortOrder;
};

export type GetCategoryTagsSortOrder =
	(typeof GetCategoryTagsSortOrder)[keyof typeof GetCategoryTagsSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryTagsSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetCategoryTagsOrderBy =
	(typeof GetCategoryTagsOrderBy)[keyof typeof GetCategoryTagsOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryTagsOrderBy = {
	name: "name",
	group_id: "group_id",
} as const;

export type GetCategoryTagsFileType =
	(typeof GetCategoryTagsFileType)[keyof typeof GetCategoryTagsFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryTagsFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategoryTagsParams = {
	api_key?: string;
	file_type?: GetCategoryTagsFileType;
	category_id: number;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetCategoryTagsOrderBy;
	sort_order?: GetCategoryTagsSortOrder;
};

export type GetCategorySeriesSortOrder =
	(typeof GetCategorySeriesSortOrder)[keyof typeof GetCategorySeriesSortOrder];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategorySeriesSortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type GetCategorySeriesOrderBy =
	(typeof GetCategorySeriesOrderBy)[keyof typeof GetCategorySeriesOrderBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategorySeriesOrderBy = {
	series_id: "series_id",
	title: "title",
	units: "units",
	frequency: "frequency",
	seasonal_adjustment: "seasonal_adjustment",
	realtime_start: "realtime_start",
	realtime_end: "realtime_end",
	last_updated: "last_updated",
	observation_start: "observation_start",
	observation_end: "observation_end",
	popularity: "popularity",
	group_popularity: "group_popularity",
} as const;

export type GetCategorySeriesFileType =
	(typeof GetCategorySeriesFileType)[keyof typeof GetCategorySeriesFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategorySeriesFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategorySeriesParams = {
	api_key?: string;
	file_type?: GetCategorySeriesFileType;
	category_id: number;
	realtime_start?: string;
	realtime_end?: string;
	limit?: number;
	offset?: number;
	order_by?: GetCategorySeriesOrderBy;
	sort_order?: GetCategorySeriesSortOrder;
	filter_variable?: string;
	filter_value?: string;
};

export type GetCategoryRelatedFileType =
	(typeof GetCategoryRelatedFileType)[keyof typeof GetCategoryRelatedFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryRelatedFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategoryRelatedParams = {
	api_key?: string;
	file_type?: GetCategoryRelatedFileType;
	category_id?: number;
	realtime_start?: string;
	realtime_end?: string;
};

export type GetCategoryChildrenFileType =
	(typeof GetCategoryChildrenFileType)[keyof typeof GetCategoryChildrenFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryChildrenFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategoryChildrenParams = {
	api_key?: string;
	file_type?: GetCategoryChildrenFileType;
	category_id?: number;
	realtime_start?: string;
	realtime_end?: string;
};

export type GetCategoryFileType =
	(typeof GetCategoryFileType)[keyof typeof GetCategoryFileType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetCategoryFileType = {
	xml: "xml",
	json: "json",
} as const;

export type GetCategoryParams = {
	/**
	 * 88e6be3b42147d9eb6726f79a6671453
	 */
	api_key?: string;
	file_type?: GetCategoryFileType;
	category_id?: number;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Get a category.
 */
export const getCategory = (
	params: GetCategoryParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategoryQueryKey = (params: GetCategoryParams) => {
	return [`/fred/category`, ...(params ? [params] : [])] as const;
};

export const getGetCategoryQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategory>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategory>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCategoryQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategory>>> = ({
		signal,
	}) => getCategory(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategory>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoryQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategory>>
>;
export type GetCategoryQueryError = AxiosError<unknown>;

/**
 * @summary Get a category.
 */
export const useGetCategory = <
	TData = Awaited<ReturnType<typeof getCategory>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategory>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategoryQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get the child categories for a specified parent category.
 */
export const getCategoryChildren = (
	params: GetCategoryChildrenParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category/children`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategoryChildrenQueryKey = (
	params: GetCategoryChildrenParams
) => {
	return [`/fred/category/children`, ...(params ? [params] : [])] as const;
};

export const getGetCategoryChildrenQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategoryChildren>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryChildrenParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryChildren>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCategoryChildrenQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCategoryChildren>>
	> = ({ signal }) => getCategoryChildren(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategoryChildren>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoryChildrenQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategoryChildren>>
>;
export type GetCategoryChildrenQueryError = AxiosError<unknown>;

/**
 * @summary Get the child categories for a specified parent category.
 */
export const useGetCategoryChildren = <
	TData = Awaited<ReturnType<typeof getCategoryChildren>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryChildrenParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryChildren>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategoryChildrenQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get related categories for a specified category.
 */
export const getCategoryRelated = (
	params: GetCategoryRelatedParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category/related`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategoryRelatedQueryKey = (
	params: GetCategoryRelatedParams
) => {
	return [`/fred/category/related`, ...(params ? [params] : [])] as const;
};

export const getGetCategoryRelatedQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategoryRelated>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryRelatedParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryRelated>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCategoryRelatedQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCategoryRelated>>
	> = ({ signal }) => getCategoryRelated(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategoryRelated>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoryRelatedQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategoryRelated>>
>;
export type GetCategoryRelatedQueryError = AxiosError<unknown>;

/**
 * @summary Get related categories for a specified category.
 */
export const useGetCategoryRelated = <
	TData = Awaited<ReturnType<typeof getCategoryRelated>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryRelatedParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryRelated>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategoryRelatedQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Retrieve series within a specified category.
 */
export const getCategorySeries = (
	params: GetCategorySeriesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category/series`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategorySeriesQueryKey = (
	params: GetCategorySeriesParams
) => {
	return [`/fred/category/series`, ...(params ? [params] : [])] as const;
};

export const getGetCategorySeriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategorySeries>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategorySeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategorySeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCategorySeriesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCategorySeries>>
	> = ({ signal }) => getCategorySeries(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategorySeries>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategorySeriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategorySeries>>
>;
export type GetCategorySeriesQueryError = AxiosError<unknown>;

/**
 * @summary Retrieve series within a specified category.
 */
export const useGetCategorySeries = <
	TData = Awaited<ReturnType<typeof getCategorySeries>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategorySeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategorySeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategorySeriesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Retrieve tags for a specific category.
 */
export const getCategoryTags = (
	params: GetCategoryTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category/tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategoryTagsQueryKey = (params: GetCategoryTagsParams) => {
	return [`/fred/category/tags`, ...(params ? [params] : [])] as const;
};

export const getGetCategoryTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategoryTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCategoryTagsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryTags>>> = ({
		signal,
	}) => getCategoryTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategoryTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoryTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategoryTags>>
>;
export type GetCategoryTagsQueryError = AxiosError<unknown>;

/**
 * @summary Retrieve tags for a specific category.
 */
export const useGetCategoryTags = <
	TData = Awaited<ReturnType<typeof getCategoryTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategoryTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Retrieve related tags for a specific category.
 */
export const getCategoryRelatedTags = (
	params: GetCategoryRelatedTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/category/related_tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetCategoryRelatedTagsQueryKey = (
	params: GetCategoryRelatedTagsParams
) => {
	return [`/fred/category/related_tags`, ...(params ? [params] : [])] as const;
};

export const getGetCategoryRelatedTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategoryRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetCategoryRelatedTagsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getCategoryRelatedTags>>
	> = ({ signal }) =>
		getCategoryRelatedTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategoryRelatedTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoryRelatedTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCategoryRelatedTags>>
>;
export type GetCategoryRelatedTagsQueryError = AxiosError<unknown>;

/**
 * @summary Retrieve related tags for a specific category.
 */
export const useGetCategoryRelatedTags = <
	TData = Awaited<ReturnType<typeof getCategoryRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetCategoryRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getCategoryRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetCategoryRelatedTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get all releases of economic data.
 */
export const getReleases = (
	params: GetReleasesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/releases`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleasesQueryKey = (params: GetReleasesParams) => {
	return [`/fred/releases`, ...(params ? [params] : [])] as const;
};

export const getGetReleasesQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleases>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleasesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleases>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetReleasesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getReleases>>> = ({
		signal,
	}) => getReleases(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleases>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleasesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleases>>
>;
export type GetReleasesQueryError = AxiosError<unknown>;

/**
 * @summary Get all releases of economic data.
 */
export const useGetReleases = <
	TData = Awaited<ReturnType<typeof getReleases>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleasesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleases>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleasesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Retrieve release dates for a specific economic data release.
 */
export const getReleaseDates = (
	params: GetReleaseDatesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/dates`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseDatesQueryKey = (params: GetReleaseDatesParams) => {
	return [`/fred/release/dates`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseDatesQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseDates>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseDatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseDates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetReleaseDatesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getReleaseDates>>> = ({
		signal,
	}) => getReleaseDates(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseDates>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseDatesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseDates>>
>;
export type GetReleaseDatesQueryError = AxiosError<unknown>;

/**
 * @summary Retrieve release dates for a specific economic data release.
 */
export const useGetReleaseDates = <
	TData = Awaited<ReturnType<typeof getReleaseDates>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseDatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseDates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseDatesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get information for a specific economic data release.
 */
export const getReleaseInfo = (
	params: GetReleaseInfoParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseInfoQueryKey = (params: GetReleaseInfoParams) => {
	return [`/fred/release`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseInfoQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseInfo>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseInfoParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseInfo>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetReleaseInfoQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getReleaseInfo>>> = ({
		signal,
	}) => getReleaseInfo(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseInfo>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseInfoQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseInfo>>
>;
export type GetReleaseInfoQueryError = AxiosError<unknown>;

/**
 * @summary Get information for a specific economic data release.
 */
export const useGetReleaseInfo = <
	TData = Awaited<ReturnType<typeof getReleaseInfo>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseInfoParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseInfo>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseInfoQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get series for a specific economic data release.
 */
export const getReleaseSeries = (
	params: GetReleaseSeriesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/series`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseSeriesQueryKey = (params: GetReleaseSeriesParams) => {
	return [`/fred/release/series`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseSeriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseSeries>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetReleaseSeriesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getReleaseSeries>>
	> = ({ signal }) => getReleaseSeries(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseSeries>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseSeriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseSeries>>
>;
export type GetReleaseSeriesQueryError = AxiosError<unknown>;

/**
 * @summary Get series for a specific economic data release.
 */
export const useGetReleaseSeries = <
	TData = Awaited<ReturnType<typeof getReleaseSeries>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseSeriesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get sources for a specific economic data release.
 */
export const getReleaseSources = (
	params: GetReleaseSourcesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/sources`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseSourcesQueryKey = (
	params: GetReleaseSourcesParams
) => {
	return [`/fred/release/sources`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseSourcesQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseSources>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseSourcesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseSources>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetReleaseSourcesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getReleaseSources>>
	> = ({ signal }) => getReleaseSources(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseSources>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseSourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseSources>>
>;
export type GetReleaseSourcesQueryError = AxiosError<unknown>;

/**
 * @summary Get sources for a specific economic data release.
 */
export const useGetReleaseSources = <
	TData = Awaited<ReturnType<typeof getReleaseSources>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseSourcesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseSources>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseSourcesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get tags for a specific economic data release.
 */
export const getReleaseTags = (
	params: GetReleaseTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseTagsQueryKey = (params: GetReleaseTagsParams) => {
	return [`/fred/release/tags`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetReleaseTagsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getReleaseTags>>> = ({
		signal,
	}) => getReleaseTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseTags>>
>;
export type GetReleaseTagsQueryError = AxiosError<unknown>;

/**
 * @summary Get tags for a specific economic data release.
 */
export const useGetReleaseTags = <
	TData = Awaited<ReturnType<typeof getReleaseTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Retrieve related tags for a specific economic data release.
 */
export const getReleaseRelatedTags = (
	params: GetReleaseRelatedTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/related_tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseRelatedTagsQueryKey = (
	params: GetReleaseRelatedTagsParams
) => {
	return [`/fred/release/related_tags`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseRelatedTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetReleaseRelatedTagsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getReleaseRelatedTags>>
	> = ({ signal }) =>
		getReleaseRelatedTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseRelatedTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseRelatedTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseRelatedTags>>
>;
export type GetReleaseRelatedTagsQueryError = AxiosError<unknown>;

/**
 * @summary Retrieve related tags for a specific economic data release.
 */
export const useGetReleaseRelatedTags = <
	TData = Awaited<ReturnType<typeof getReleaseRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseRelatedTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/**
 * @summary Get data tables for a specific economic data release.
 */
export const getReleaseTables = (
	params: GetReleaseTablesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
	return axios.get(`/fred/release/tables`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetReleaseTablesQueryKey = (params: GetReleaseTablesParams) => {
	return [`/fred/release/tables`, ...(params ? [params] : [])] as const;
};

export const getGetReleaseTablesQueryOptions = <
	TData = Awaited<ReturnType<typeof getReleaseTables>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseTablesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseTables>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetReleaseTablesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getReleaseTables>>
	> = ({ signal }) => getReleaseTables(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getReleaseTables>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetReleaseTablesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getReleaseTables>>
>;
export type GetReleaseTablesQueryError = AxiosError<unknown>;

/**
 * @summary Get data tables for a specific economic data release.
 */
export const useGetReleaseTables = <
	TData = Awaited<ReturnType<typeof getReleaseTables>>,
	TError = AxiosError<unknown>,
>(
	params: GetReleaseTablesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getReleaseTables>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetReleaseTablesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeries = (
	params?: GetSeriesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesQueryKey = (params?: GetSeriesParams) => {
	return [`/fred/series`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeries>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSeriesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeries>>> = ({
		signal,
	}) => getSeries(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeries>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeries>>
>;
export type GetSeriesQueryError = AxiosError<unknown>;

export const useGetSeries = <
	TData = Awaited<ReturnType<typeof getSeries>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesCategories = (
	params?: GetSeriesCategoriesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/categories`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesCategoriesQueryKey = (
	params?: GetSeriesCategoriesParams
) => {
	return [`/fred/series/categories`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesCategoriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesCategories>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesCategoriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesCategories>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesCategoriesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesCategories>>
	> = ({ signal }) => getSeriesCategories(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesCategories>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesCategoriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesCategories>>
>;
export type GetSeriesCategoriesQueryError = AxiosError<unknown>;

export const useGetSeriesCategories = <
	TData = Awaited<ReturnType<typeof getSeriesCategories>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesCategoriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesCategories>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesCategoriesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesObservations = (
	params?: GetSeriesObservationsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/observations`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesObservationsQueryKey = (
	params?: GetSeriesObservationsParams
) => {
	return [`/fred/series/observations`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesObservationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesObservations>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesObservationsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesObservations>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesObservationsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesObservations>>
	> = ({ signal }) =>
		getSeriesObservations(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesObservations>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesObservationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesObservations>>
>;
export type GetSeriesObservationsQueryError = AxiosError<unknown>;

export const useGetSeriesObservations = <
	TData = Awaited<ReturnType<typeof getSeriesObservations>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesObservationsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesObservations>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesObservationsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesRelease = (
	params?: GetSeriesReleaseParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/release`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesReleaseQueryKey = (
	params?: GetSeriesReleaseParams
) => {
	return [`/fred/series/release`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesReleaseQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesRelease>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesReleaseParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesRelease>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesReleaseQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesRelease>>
	> = ({ signal }) => getSeriesRelease(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesRelease>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesReleaseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesRelease>>
>;
export type GetSeriesReleaseQueryError = AxiosError<unknown>;

export const useGetSeriesRelease = <
	TData = Awaited<ReturnType<typeof getSeriesRelease>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesReleaseParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesRelease>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesReleaseQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

/*
rsponse of form:

frequency
: 
"Weekly, As of Wednesday"
frequency_short
: 
"W"
group_popularity
: 
1
id
: 
"RESPPALGAMD15XCH1NWW"
last_updated
: 
"2024-10-10 15:36:46-05"
observation_end
: 
"2024-10-09"
observation_start
: 
"2002-12-18"
popularity
: 
1
realtime_end
: 
"2024-10-12"
realtime_start
: 
"2024-10-12"
seasonal_adjustment
: 
"Not Seasonally Adjusted"
seasonal_adjustment_short
: 
"NSA"
title
: 
"Assets: Securities Held Outright: Federal Agency Debt Securities: Maturing Within 15 Days: Change in Wednesday Level from Previous Wednesday Level"
units
: 
"Millions of U.S. Dollars"
units_short
: 
"Mil. of U.S. $"

*/

export interface SeriesSearchData {
	frequency: string;
	frequency_short: string;
	group_popularity: number;
	id: string;
	last_updated: string;
	observation_end: string;
	observation_start: string;
	popularity: number;
	realtime_end: string;
	realtime_start: string;
	seasonal_adjustment: string;
	seasonal_adjustment_short: string;
	title: string;
	units: string;
	units_short: string;
}

export const getSeriesSearch = (
	params?: GetSeriesSearchParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<SeriesSearchData>> => {
	return axios.get(`/fred/series/search`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesSearchQueryKey = (params?: GetSeriesSearchParams) => {
	return [`/fred/series/search`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesSearchQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesSearch>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearch>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSeriesSearchQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesSearch>>> = ({
		signal,
	}) => getSeriesSearch(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesSearch>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesSearchQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesSearch>>
>;
export type GetSeriesSearchQueryError = AxiosError<unknown>;

export const useGetSeriesSearch = <
	TData = Awaited<ReturnType<typeof getSeriesSearch>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearch>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesSearchQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesSearchTags = (
	params?: GetSeriesSearchTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/search/tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesSearchTagsQueryKey = (
	params?: GetSeriesSearchTagsParams
) => {
	return [`/fred/series/search/tags`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesSearchTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesSearchTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearchTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesSearchTagsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesSearchTags>>
	> = ({ signal }) => getSeriesSearchTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesSearchTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesSearchTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesSearchTags>>
>;
export type GetSeriesSearchTagsQueryError = AxiosError<unknown>;

export const useGetSeriesSearchTags = <
	TData = Awaited<ReturnType<typeof getSeriesSearchTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearchTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesSearchTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesSearchRelatedTags = (
	params?: GetSeriesSearchRelatedTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/search/related_tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesSearchRelatedTagsQueryKey = (
	params?: GetSeriesSearchRelatedTagsParams
) => {
	return [
		`/fred/series/search/related_tags`,
		...(params ? [params] : []),
	] as const;
};

export const getGetSeriesSearchRelatedTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesSearchRelatedTagsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>
	> = ({ signal }) =>
		getSeriesSearchRelatedTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesSearchRelatedTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>
>;
export type GetSeriesSearchRelatedTagsQueryError = AxiosError<unknown>;

export const useGetSeriesSearchRelatedTags = <
	TData = Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesSearchRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesSearchRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesSearchRelatedTagsQueryOptions(
		params,
		options
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesTags = (
	params?: GetSeriesTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesTagsQueryKey = (params?: GetSeriesTagsParams) => {
	return [`/fred/series/tags`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSeriesTagsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSeriesTags>>> = ({
		signal,
	}) => getSeriesTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesTags>>
>;
export type GetSeriesTagsQueryError = AxiosError<unknown>;

export const useGetSeriesTags = <
	TData = Awaited<ReturnType<typeof getSeriesTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesUpdates = (
	params?: GetSeriesUpdatesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/updates`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesUpdatesQueryKey = (
	params?: GetSeriesUpdatesParams
) => {
	return [`/fred/series/updates`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesUpdatesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesUpdates>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesUpdatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesUpdates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesUpdatesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesUpdates>>
	> = ({ signal }) => getSeriesUpdates(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesUpdates>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesUpdatesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesUpdates>>
>;
export type GetSeriesUpdatesQueryError = AxiosError<unknown>;

export const useGetSeriesUpdates = <
	TData = Awaited<ReturnType<typeof getSeriesUpdates>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesUpdatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesUpdates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesUpdatesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSeriesVintagedates = (
	params?: GetSeriesVintagedatesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/series/vintagedates`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSeriesVintagedatesQueryKey = (
	params?: GetSeriesVintagedatesParams
) => {
	return [`/fred/series/vintagedates`, ...(params ? [params] : [])] as const;
};

export const getGetSeriesVintagedatesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSeriesVintagedates>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesVintagedatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesVintagedates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSeriesVintagedatesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSeriesVintagedates>>
	> = ({ signal }) =>
		getSeriesVintagedates(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSeriesVintagedates>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSeriesVintagedatesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSeriesVintagedates>>
>;
export type GetSeriesVintagedatesQueryError = AxiosError<unknown>;

export const useGetSeriesVintagedates = <
	TData = Awaited<ReturnType<typeof getSeriesVintagedates>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSeriesVintagedatesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSeriesVintagedates>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSeriesVintagedatesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSources = (
	params?: GetSourcesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/sources`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSourcesQueryKey = (params?: GetSourcesParams) => {
	return [`/fred/sources`, ...(params ? [params] : [])] as const;
};

export const getGetSourcesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSources>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourcesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSources>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSourcesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSources>>> = ({
		signal,
	}) => getSources(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSources>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSourcesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSources>>
>;
export type GetSourcesQueryError = AxiosError<unknown>;

export const useGetSources = <
	TData = Awaited<ReturnType<typeof getSources>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourcesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSources>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSourcesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSource = (
	params?: GetSourceParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/source`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSourceQueryKey = (params?: GetSourceParams) => {
	return [`/fred/source`, ...(params ? [params] : [])] as const;
};

export const getGetSourceQueryOptions = <
	TData = Awaited<ReturnType<typeof getSource>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourceParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSource>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetSourceQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSource>>> = ({
		signal,
	}) => getSource(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSource>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSourceQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSource>>
>;
export type GetSourceQueryError = AxiosError<unknown>;

export const useGetSource = <
	TData = Awaited<ReturnType<typeof getSource>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourceParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSource>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSourceQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getSourceReleases = (
	params?: GetSourceReleasesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/source/releases`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetSourceReleasesQueryKey = (
	params?: GetSourceReleasesParams
) => {
	return [`/fred/source/releases`, ...(params ? [params] : [])] as const;
};

export const getGetSourceReleasesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSourceReleases>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourceReleasesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSourceReleases>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetSourceReleasesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getSourceReleases>>
	> = ({ signal }) => getSourceReleases(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSourceReleases>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetSourceReleasesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSourceReleases>>
>;
export type GetSourceReleasesQueryError = AxiosError<unknown>;

export const useGetSourceReleases = <
	TData = Awaited<ReturnType<typeof getSourceReleases>>,
	TError = AxiosError<unknown>,
>(
	params?: GetSourceReleasesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getSourceReleases>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetSourceReleasesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getTags = (
	params?: GetTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetTagsQueryKey = (params?: GetTagsParams) => {
	return [`/fred/tags`, ...(params ? [params] : [])] as const;
};

export const getGetTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetTagsParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({
		signal,
	}) => getTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTags>>
>;
export type GetTagsQueryError = AxiosError<unknown>;

export const useGetTags = <
	TData = Awaited<ReturnType<typeof getTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetTagsParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getRelatedTags = (
	params?: GetRelatedTagsParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/related_tags`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetRelatedTagsQueryKey = (params?: GetRelatedTagsParams) => {
	return [`/fred/related_tags`, ...(params ? [params] : [])] as const;
};

export const getGetRelatedTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetRelatedTagsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getRelatedTags>>> = ({
		signal,
	}) => getRelatedTags(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getRelatedTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetRelatedTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getRelatedTags>>
>;
export type GetRelatedTagsQueryError = AxiosError<unknown>;

export const useGetRelatedTags = <
	TData = Awaited<ReturnType<typeof getRelatedTags>>,
	TError = AxiosError<unknown>,
>(
	params?: GetRelatedTagsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getRelatedTags>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetRelatedTagsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getTagsSeries = (
	params?: GetTagsSeriesParams,
	options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
	return axios.get(`/fred/tags/series`, {
		...options,
		params: { ...params, ...options?.params },
	});
};

export const getGetTagsSeriesQueryKey = (params?: GetTagsSeriesParams) => {
	return [`/fred/tags/series`, ...(params ? [params] : [])] as const;
};

export const getGetTagsSeriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getTagsSeries>>,
	TError = AxiosError<unknown>,
>(
	params?: GetTagsSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getTagsSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
) => {
	const { query: queryOptions, axios: axiosOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTagsSeriesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTagsSeries>>> = ({
		signal,
	}) => getTagsSeries(params, { signal, ...axiosOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getTagsSeries>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetTagsSeriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getTagsSeries>>
>;
export type GetTagsSeriesQueryError = AxiosError<unknown>;

export const useGetTagsSeries = <
	TData = Awaited<ReturnType<typeof getTagsSeries>>,
	TError = AxiosError<unknown>,
>(
	params?: GetTagsSeriesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getTagsSeries>>,
			TError,
			TData
		>;
		axios?: AxiosRequestConfig;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const queryOptions = getGetTagsSeriesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
};

export const getGetCategoryMockHandler = () => {
	return http.get("*/fred/category", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetCategoryChildrenMockHandler = () => {
	return http.get("*/fred/category/children", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetCategoryRelatedMockHandler = () => {
	return http.get("*/fred/category/related", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetCategorySeriesMockHandler = () => {
	return http.get("*/fred/category/series", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetCategoryTagsMockHandler = () => {
	return http.get("*/fred/category/tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetCategoryRelatedTagsMockHandler = () => {
	return http.get("*/fred/category/related_tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleasesMockHandler = () => {
	return http.get("*/fred/releases", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseDatesMockHandler = () => {
	return http.get("*/fred/release/dates", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseInfoMockHandler = () => {
	return http.get("*/fred/release", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseSeriesMockHandler = () => {
	return http.get("*/fred/release/series", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseSourcesMockHandler = () => {
	return http.get("*/fred/release/sources", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseTagsMockHandler = () => {
	return http.get("*/fred/release/tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseRelatedTagsMockHandler = () => {
	return http.get("*/fred/release/related_tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetReleaseTablesMockHandler = () => {
	return http.get("*/fred/release/tables", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesMockHandler = () => {
	return http.get("*/fred/series", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesCategoriesMockHandler = () => {
	return http.get("*/fred/series/categories", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesObservationsMockHandler = () => {
	return http.get("*/fred/series/observations", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesReleaseMockHandler = () => {
	return http.get("*/fred/series/release", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesSearchMockHandler = () => {
	return http.get("*/fred/series/search", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesSearchTagsMockHandler = () => {
	return http.get("*/fred/series/search/tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesSearchRelatedTagsMockHandler = () => {
	return http.get("*/fred/series/search/related_tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesTagsMockHandler = () => {
	return http.get("*/fred/series/tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesUpdatesMockHandler = () => {
	return http.get("*/fred/series/updates", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSeriesVintagedatesMockHandler = () => {
	return http.get("*/fred/series/vintagedates", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSourcesMockHandler = () => {
	return http.get("*/fred/sources", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSourceMockHandler = () => {
	return http.get("*/fred/source", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetSourceReleasesMockHandler = () => {
	return http.get("*/fred/source/releases", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetTagsMockHandler = () => {
	return http.get("*/fred/tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetRelatedTagsMockHandler = () => {
	return http.get("*/fred/related_tags", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};

export const getGetTagsSeriesMockHandler = () => {
	return http.get("*/fred/tags/series", async () => {
		await delay(1000);
		return new HttpResponse(null, {
			status: 200,
			headers: {
				"Content-Type": "application/json",
			},
		});
	});
};
export const getFredApiMock = () => [
	getGetCategoryMockHandler(),
	getGetCategoryChildrenMockHandler(),
	getGetCategoryRelatedMockHandler(),
	getGetCategorySeriesMockHandler(),
	getGetCategoryTagsMockHandler(),
	getGetCategoryRelatedTagsMockHandler(),
	getGetReleasesMockHandler(),
	getGetReleaseDatesMockHandler(),
	getGetReleaseInfoMockHandler(),
	getGetReleaseSeriesMockHandler(),
	getGetReleaseSourcesMockHandler(),
	getGetReleaseTagsMockHandler(),
	getGetReleaseRelatedTagsMockHandler(),
	getGetReleaseTablesMockHandler(),
	getGetSeriesMockHandler(),
	getGetSeriesCategoriesMockHandler(),
	getGetSeriesObservationsMockHandler(),
	getGetSeriesReleaseMockHandler(),
	getGetSeriesSearchMockHandler(),
	getGetSeriesSearchTagsMockHandler(),
	getGetSeriesSearchRelatedTagsMockHandler(),
	getGetSeriesTagsMockHandler(),
	getGetSeriesUpdatesMockHandler(),
	getGetSeriesVintagedatesMockHandler(),
	getGetSourcesMockHandler(),
	getGetSourceMockHandler(),
	getGetSourceReleasesMockHandler(),
	getGetTagsMockHandler(),
	getGetRelatedTagsMockHandler(),
	getGetTagsSeriesMockHandler(),
];
